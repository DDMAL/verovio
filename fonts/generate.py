import base64
import json
import os
import subprocess
import sys
import shutil
from argparse import ArgumentParser, Namespace
import xml.etree.ElementTree as ElementTree
from pathlib import Path
from svgpathtools import Path as SvgPath

# Define svg namespace
from typing import Optional

SVG_NS = {"svg": "http://www.w3.org/2000/svg"}

SMUFL_HEADER = """/////////////////////////////////////////////////////////////////////////////
// Name:        smufl.h
// Author:      Laurent Pugin
// Created:     2014-2022
// Copyright (c) Authors and others. All rights reserved.
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// NOTE: this file was generated by the ./fonts/generate smufl script
// and should not be edited because changes will be lost.
/////////////////////////////////////////////////////////////////////////////

#ifndef __VRV_SMUFL_H__
#define __VRV_SMUFL_H__

//----------------------------------------------------------------------------

namespace vrv {{

//----------------------------------------------------------------------------
// SMUFL glyphs available by default in Verovio
//----------------------------------------------------------------------------

enum {{
{smufl_glyph_list}
}};

/** The number of glyphs for verification **/
#define SMUFL_COUNT {len_smufl_codes}

}} // namespace vrv

#endif
"""

FONTFORGE_SCRIPT = """import os; fontforge.open("{input_fontpath}").generate("{output_fontpath}")"""

WOFF2_WRAPPER = """<style type='text/css'>
@font-face {{
    font-family: '{fontname}';
    src: url(data:application/font-woff2;charset=utf-8;base64,{b64encoding}) format('woff2');
    font-weight: normal;
    font-style: normal;
}}
</style>"""

def generate_smufl(opts: Namespace) -> bool:
    """
    Generates the `smufl.h` file for Verovio.

    :param opts: A set of options from the argument parser sub-command.
    :return: True if successful, False otherwise.
    """
    supported_glyphs_fname: str = opts.supported
    header_out_dir: str = opts.header_out
    supported_path: Path = Path(supported_glyphs_fname)
    header_out_path: Path = Path(header_out_dir)

    if not supported_path.is_file() or not os.access(supported_path, os.R_OK):
        print(f"Could not find or read {supported_glyphs_fname} file.")
        return False

    if not os.access(header_out_path, os.W_OK):
        print(f"Could not write to {header_out_dir}.")
        return False

    supported_glyphs: dict = __get_supported_glyph_codes(supported_glyphs_fname)

    fmt_supported_glyphs: list = [
        f"    SMUFL_{gcode}_{gname} = 0x{gcode}," for gcode, gname in supported_glyphs.items()
    ]
    fmt_glyph_list = "\n".join(fmt_supported_glyphs)
    fmt_header = SMUFL_HEADER.format(smufl_glyph_list=fmt_glyph_list, len_smufl_codes=len(fmt_supported_glyphs))

    with open(Path(header_out_path, "smufl.h"), "w") as header_inc:
        header_inc.write(fmt_header)

    return True


def extract_fonts(opts: Namespace) -> bool:
    """
    Takes a font file and extracts the necessary files for Verovio. Generates a glyph file for each glyph, and an SVG
    font file containing only the supported SMuFL glyphs.

    :param opts: A set of options from the argument parser sub-command.
    :return: True if successful, False otherwise.
    """
    source_dir: str = opts.source
    font_dir: str = opts.fontname
    data_dir: str = opts.data

    source_pth: Path = Path(source_dir)
    font_data_pth: Path = Path(source_pth, font_dir)
    metadata_pth: Path = Path(source_pth, font_data_pth, f"{font_dir.lower()}_metadata.json")
    font_pth: Path = Path(source_pth, font_data_pth, f"{font_dir}.svg")
    data_pth: Path = Path(data_dir)
    glyph_file_pth: Path = Path(data_pth, font_dir)
    output_pth: Path = Path(data_pth, f"{font_dir}.xml")

    if not font_data_pth.is_dir() or not os.access(font_data_pth, os.R_OK):
        print(f"Could not read font information from {str(font_data_pth)}")
        return False

    if not os.access(metadata_pth, os.R_OK):
        print(f"Could not read {str(metadata_pth)}. Does it exist?")
        return False

    if not os.access(font_pth, os.R_OK):
        print(f"Could not read {str(font_pth)}. Does it exist?")
        return False

    if not os.access(output_pth, os.W_OK):
        print(f"Could not write to {str(output_pth)}. Check permissions.")
        return False

    if not glyph_file_pth.is_dir():
        os.makedirs(glyph_file_pth, exist_ok=True)

    svg_data = __read_svg_font_file(str(font_pth))
    if not svg_data:
        return False

    family, units, hax, glyphs = svg_data

    supported_glyphs: dict = __get_supported_glyph_codes(opts.supported)
    metadata: dict = json.load(open(metadata_pth, "r"))
    alternate_glyphs = __get_alternate_glyphs(supported_glyphs, metadata)

    if alternate_glyphs:
        supported_glyphs.update(alternate_glyphs)

    __write_xml_glyphs(glyphs, supported_glyphs, units, glyph_file_pth)
    __write_xml_svg(glyphs, supported_glyphs, family, units, hax, metadata, output_pth)
    return True


def generate_woff2(opts: Namespace) -> bool:
    """
    Uses fontforge to generate a woff2 file from a given font.

    :param opts: A set of options from the argument parser sub-command.
    :return: True if successful, False otherwise.
    """
    convert_res: bool = __fontforge_helper(opts, "woff2")
    if not convert_res:
        print("A problem happened with the fontforge conversion to WOFF2.")
        return False

    fontname: str = opts.fontname
    output_fontname: Path = Path(opts.data, f"{fontname}.woff2")

    # If the `--wrap` flag is passed, wraps the woff2 font in a CSS font-face statement with base64 encoding.
    if opts.wrap:
        css_filename: Path = Path(opts.data, f"{fontname}.woff2.xml")
        with open(output_fontname, "rb") as woff2_content:
            b64_encoding: bytes = base64.urlsafe_b64encode(woff2_content.read())
            with open(css_filename, "w") as css_content:
                fmt_css: str = WOFF2_WRAPPER.format(fontname=fontname, b64encoding=b64_encoding.decode())
                css_content.write(fmt_css)

    # If the `--no-clean` flag is passed, then this will be skipped.
    if not opts.no_clean:
        afm_file: Path = Path(opts.data, f"{fontname}.afm")
        afm_file.unlink(missing_ok=True)

    return True


def generate_svg(opts) -> bool:
    convert_res: bool = __fontforge_helper(opts, "svg")
    if not convert_res:
        print("A problem happened with the fontforge conversion to SVG.")
        return False

    return True

#########
# Private implementation methods.
#########


def __fontforge_helper(opts: Namespace, format: str) -> bool:
    if format not in ("svg", "woff2"):
        print(f"Unknown conversion format {format}. Must be either 'svg' or 'woff2'.")
        return False

    fontforge_path: Optional[str] = shutil.which("fontforge") if not opts.fontforge else opts.fontforge
    if fontforge_path is None:
        print(f"Could not find fontforge. It is required for this operation.")
        return False

    if not os.access(fontforge_path, os.X_OK):
        print(f"{fontforge_path} does not point to an executable.")
        return False

    font: str = opts.fontfile
    font_pth: Path = Path(font)
    if not font_pth.is_file() or not os.access(font_pth, os.R_OK):
        print(f"Could not find or read {str(font_pth)}.")
        return False

    fontforge_cmd: list = [
        fontforge_path,
        "-lang=py"
        "-"
    ]
    fontname: str = opts.fontname
    if format == "woff2":
        output_fontname = Path(opts.data, f"{fontname}.{format}")
    else:
        output_fontname = Path(font_pth.parent, f"{fontname}.{format}")

    ff_script: bytes = FONTFORGE_SCRIPT.format(input_fontpath=str(font_pth),
                                               output_fontpath=str(output_fontname)).encode()
    proc: subprocess.CompletedProcess = subprocess.run(fontforge_cmd, input=ff_script)

    if proc.returncode != 0:
        print(f"Fontforge exited with an error.")
        return False

    return True


def __get_supported_glyph_codes(supported: str) -> dict:
    """Retrieve dictionary with supported SMuFL codepoints and name."""
    supported_xml = ElementTree.parse(supported)
    glyphs = supported_xml.findall(".//glyph")
    return {g.attrib["glyph-code"]: g.attrib["smufl-name"] for g in glyphs}


def __read_svg_font_file(fontfile: str) -> Optional[tuple[str, str, str, list[ElementTree.Element]]]:
    font_xml: ElementTree = ElementTree.parse(fontfile)
    font_el: ElementTree.Element = font_xml.find("svg:defs/svg:font", SVG_NS)
    if not font_el:
        print(f"Could not find a font definition in {fontfile}.")
        return None

    font_faces: list[ElementTree.Element] = font_xml.findall(".//svg:font-face", SVG_NS)
    if len(font_faces) != 1:
        print(f"Error: the file {fontfile} should have a unique font-face element.")
        print(f"Please check that the svg has correct namespace: {SVG_NS['svg']}.")
        return None

    font_family: str = font_faces[0].attrib.get("font-family", "")
    units_per_em: str = font_faces[0].attrib.get("units-per-em", "")
    if not font_family or not units_per_em:
        print(f"Error: Could not find a font family or units-per-em definition.")
        return None

    default_hax = font_el.attrib.get("horiz-adv-x", "0")
    glyphs: list[ElementTree.Element] = font_xml.findall(".//svg:glyph", SVG_NS)
    return font_family, units_per_em, default_hax, glyphs


def __write_xml_glyphs(
        glyphs: list[ElementTree.Element],
        supported_glyphs: dict,
        units_per_em: str,
        output: Path) -> None:
    for glyph in glyphs:
        code: str = glyph.attrib.get("glyph-name")[-4:]
        if code not in supported_glyphs:
            continue

        rt: ElementTree.Element = ElementTree.Element("symbol")
        rt.set("id", code)
        rt.set("viewBox", f"0 0 {units_per_em} {units_per_em}")
        rt.set("overflow", "inherit")
        if "d" in glyph.attrib:
            pth = ElementTree.SubElement(rt, "path")
            pth.set("transform", "scale(1,-1)")
            pth.set("d", glyph.attrib["d"])

        tr: ElementTree.ElementTree = ElementTree.ElementTree(rt)
        glyph_pth: Path = Path(output, f"{code}.xml")
        tr.write(str(glyph_pth), encoding="UTF-8")


def __write_xml_svg(
        glyphs: list[ElementTree.Element],
        supported_glyphs: dict,
        family: str,
        units_per_em: str,
        default_hax: str,
        metadata: dict,
        output: Path) -> None:
    root: ElementTree.Element = ElementTree.Element("bounding-boxes")
    root.set("font-family", family)
    root.set("units-per-em", units_per_em)
    all_glyph_anchors: dict = metadata.get("glyphsWithAnchors", {})

    for glyph in glyphs:
        code: str = glyph.attrib.get("glyph-name")[-4:]
        if code not in supported_glyphs:
            continue

        g_element: ElementTree.Element = ElementTree.SubElement(root, "g")
        g_element.set("c", code)

        if "d" in glyph.attrib:
            svg_path = SvgPath(glyph.attrib["d"])
            xmin, xmax, ymin, ymax = svg_path.bbox()
            g_element.set("x", str(round(xmin, 2)))
            g_element.set("y", str(round(ymin, 2)))
            g_element.set("w", str(round(xmax - xmin, 2)))
            g_element.set("h", str(round(ymax - ymin, 2)))
        else:
            g_element.set("x", str(0.0))
            g_element.set("y", str(0.0))
            g_element.set("w", str(0.0))
            g_element.set("h", str(0.0))

        # set set horiz-av-x
        g_element.set("h-a-x", glyph.attrib.get("horiz-adv-x", default_hax))
        if not float(g_element.get("w")):
            g_element.set("w", glyph.attrib.get("horiz-adv-x", default_hax))

        current_glyphname: Optional[str] = supported_glyphs.get(code)
        if current_glyphname:
            g_element.set("n", current_glyphname)
            g_anchors: dict = all_glyph_anchors.get(current_glyphname, {})
            for nm, anc in g_anchors.items():
                a_element = ElementTree.SubElement(g_element, "a")
                a_element.set("n", nm)
                a_element.set("x", str(round(anc[0], 2)))
                a_element.set("y", str(round(anc[1], 2)))

    tree: ElementTree = ElementTree.ElementTree(root)
    ElementTree.indent(tree)
    tree.write(str(output), encoding="UTF-8", xml_declaration=True)


def __get_alternate_glyphs(glyphs: dict, metadata: dict) -> dict:
    glyph_alternates: dict = metadata.get("glyphsWithAlternates", {})
    inverted_glyphs: dict = {v: k for k, v in glyphs.items()}
    additional_glyphs: dict = {}
    for name, alternates in glyph_alternates.items():
        code: Optional[str] = inverted_glyphs.get(name)
        if not code:
            print(f"Could not find code for {name}")
            continue

        for alt in alternates["alternates"]:
            additional_glyphs[alt["codepoint"][2:]] = alt["name"]

    return additional_glyphs


if __name__ == "__main__":
    cli = ArgumentParser()
    subparsers = cli.add_subparsers(help="[sub-command] help")

    smufl_description = """
    Extracts the supported glyphs from an SVG font file and creates the SMuFL header file for Verovio. 
    """
    parser_smufl = subparsers.add_parser("smufl", description=smufl_description)
    parser_smufl.add_argument("--supported", help="A supported.xml file", default="./supported.xml")
    parser_smufl.add_argument("--header-out", default="../include/vrv/")
    parser_smufl.set_defaults(func=generate_smufl)

    extract_description = """
    Extracts the supported glyphs from an SVG font file. Creates a new SVG font file, as well as individual SVG
    files for each glyph.
    """
    parser_extract = subparsers.add_parser("extract", description=extract_description)
    parser_extract.add_argument("fontname")
    parser_extract.add_argument("--supported", help="A supported.xml file", default="./supported.xml")
    parser_extract.add_argument("--data", help="Path to the Verovio data directory", default="../data")
    parser_extract.add_argument("--source", help="The font source parent directory", default="./")
    parser_extract.set_defaults(func=extract_fonts)

    woff2_description = """
    Creates a WOFF2 file of the font using fontforge. 
    
    Optionally base64 encodes the WOFF2 output and wraps it in a CSS @font-face definition.
    """

    fontname_help = """
    The name of the font. WOFF2 files will be generated with this name. 
    Also sets the font-family in the CSS @font-face description.
    """
    parser_woff2 = subparsers.add_parser("woff2", description=woff2_description)
    parser_woff2.add_argument("fontname",
                              help=fontname_help)
    parser_woff2.add_argument("fontfile",
                              help="The path to the font file. Can be any font file supported by fontforge.")
    parser_woff2.add_argument("--data", help="Path to the Verovio data directory", default="../data")
    parser_woff2.add_argument("--fontforge",
                              help="Path to fontforge binary (default is to auto-detect on the path)", default=None)
    parser_woff2.add_argument("--wrap",
                              help="Base64 encodes a woff2 font and wraps it in a CSS container", action="store_true")
    parser_woff2.add_argument("--no-clean",
                              help="Does not clean the .afm file from the font directory after generating",
                              action="store_true")
    parser_woff2.set_defaults(func=generate_woff2)

    svg_description = """
    Creates an SVG font from any other font file supported by fontforge.
    """
    parser_svg = subparsers.add_parser("svg", description=svg_description)
    parser_svg.add_argument("fontname", help="The name of the font. SVG files will be generated with this name")
    parser_svg.add_argument("fontfile",
                            help="The path to the source font file. Can be any font file supported by fontforge.")
    parser_svg.add_argument("--fontforge",
                            help="Path to fontforge binary (default is to auto-detect on the path)",
                            default=None)
    parser_svg.add_argument("--no-clean",
                            help="Does not clean the .afm file from the font directory after generating",
                            action="store_true")
    parser_svg.set_defaults(func=generate_svg)

    opts: Namespace = cli.parse_args()
    res: bool = opts.func(opts)

    if not res:
        print("An error has occurred.")
        sys.exit(1)

    sys.exit(0)




